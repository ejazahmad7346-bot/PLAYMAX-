// server.js
import express from "express";
import bodyParser from "body-parser";
import multer from "multer";
import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";
import { Pool } from "pg";
import ffmpeg from "fluent-ffmpeg";
import fs from "fs/promises";
import fsSync from "fs";
import { Storage } from "@google-cloud/storage";
import dotenv from "dotenv";

dotenv.config();

const app = express();
app.use(bodyParser.json());

const JWT_SECRET = process.env.JWT_SECRET || "supersecret";
const GCS_BUCKET = process.env.GCS_BUCKET || "your-gcs-bucket";
const GOOGLE_PROJECT_ID = process.env.GOOGLE_PROJECT_ID || "your-project-id";
const GOOGLE_KEYFILE = process.env.GOOGLE_KEYFILE || "./gcs-key.json";
const BASE_URL = process.env.BASE_URL || "http://localhost:3000";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL || "postgres://user:pass@localhost:5432/videosdb"
});

const storage = new Storage({
  projectId: GOOGLE_PROJECT_ID,
  keyFilename: GOOGLE_KEYFILE,
});
const bucket = storage.bucket(GCS_BUCKET);

if (!fsSync.existsSync("uploads")) {
  fsSync.mkdirSync("uploads");
}

const upload = multer({
  dest: "uploads/",
  limits: { fileSize: 500 * 1024 * 1024 }
});

async function initDb() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username TEXT UNIQUE,
        password TEXT
      );
    `);

    await pool.query(`
      CREATE TABLE IF NOT EXISTS videos (
        id SERIAL PRIMARY KEY,
        title TEXT,
        description TEXT,
        gcs_path TEXT,
        thumbnail_path TEXT,
        views INT DEFAULT 0,
        likes INT DEFAULT 0,
        dislikes INT DEFAULT 0,
        user_id INT REFERENCES users(id) ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      );
    `);

    await pool.query(`
      CREATE TABLE IF NOT EXISTS video_reactions (
        id SERIAL PRIMARY KEY,
        user_id INT REFERENCES users(id) ON DELETE CASCADE,
        video_id INT REFERENCES videos(id) ON DELETE CASCADE,
        type TEXT CHECK(type IN ('like', 'dislike')),
        UNIQUE(user_id, video_id)
      );
    `);
    
    // New table for subscriptions
    await pool.query(`
      CREATE TABLE IF NOT EXISTS subscriptions (
        id SERIAL PRIMARY KEY,
        subscriber_id INT REFERENCES users(id) ON DELETE CASCADE,
        channel_id INT REFERENCES users(id) ON DELETE CASCADE,
        UNIQUE(subscriber_id, channel_id)
      );
    `);
    
  } catch (err) {
    console.error("DB initialization error:", err);
  }
}
initDb();

function auth(req, res, next) {
  try {
    const header = req.headers.authorization;
    if (!header) return res.status(401).json({ error: "No token provided." });

    const parts = header.split(" ");
    if (parts.length !== 2 || parts[0] !== "Bearer") {
      return res.status(401).json({ error: "Invalid token format." });
    }

    const token = parts[1];
    req.user = jwt.verify(token, JWT_SECRET);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Invalid or expired token." });
  }
}

// Helper function for consistent pagination
async function getPaginatedResults(query, params, page, limit) {
  const offset = (page - 1) * limit;
  const { rows } = await pool.query(`${query} LIMIT $1 OFFSET $2`, [limit, offset, ...params]);
  const totalRes = await pool.query(`SELECT COUNT(*) FROM (${query}) AS count`, params);
  const total = parseInt(totalRes.rows[0].count);
  return { videos: rows, meta: { page, limit, total } };
}

// Authentication Endpoints
app.post("/api/auth/register", async (req, res) => {
  const { username, password } = req.body;
  if (!username || !password) return res.status(400).json({ error: "Missing username or password." });
  const hashed = await bcrypt.hash(password, 10);
  try {
    await pool.query("INSERT INTO users(username, password) VALUES($1, $2)", [username, hashed]);
    res.json({ message: "User registered successfully." });
  } catch (err) {
    if (err.code === '23505') {
      return res.status(409).json({ error: "Username already exists." });
    }
    res.status(500).json({ error: "Registration failed.", details: err.message });
  }
});

app.post("/api/auth/login", async (req, res) => {
  const { username, password } = req.body;
  if (!username || !password) return res.status(400).json({ error: "Missing username or password." });
  const { rows } = await pool.query("SELECT id, password FROM users WHERE username = $1", [username]);
  if (rows.length === 0) return res.status(401).json({ error: "Invalid username or password." });
  const user = rows[0];
  const match = await bcrypt.compare(password, user.password);
  if (!match) return res.status(401).json({ error: "Invalid username or password." });
  const token = jwt.sign({ id: user.id, username }, JWT_SECRET, { expiresIn: "7d" });
  res.json({ token });
});

// Video Upload
app.post("/api/videos/upload", auth, upload.single("video"), async (req, res) => {
  const file = req.file;
  const { title, description } = req.body;
  if (!file || !title) return res.status(400).json({ error: "Missing video file or title." });

  try {
    const thumbPath = `uploads/${file.filename}.jpg`;
    await new Promise((resolve, reject) => {
      ffmpeg(file.path)
        .screenshots({
          count: 1,
          folder: "uploads",
          filename: `${file.filename}.jpg`,
          size: "320x240",
        })
        .on("end", resolve)
        .on("error", reject);
    });

    const gcsVideoPath = `videos/${file.filename}-${file.originalname}`;
    await bucket.upload(file.path, { destination: gcsVideoPath });
    const gcsThumbPath = `thumbnails/${file.filename}.jpg`;
    await bucket.upload(thumbPath, { destination: gcsThumbPath });

    const { rows } = await pool.query(
      `INSERT INTO videos(title, description, gcs_path, thumbnail_path, user_id) 
       VALUES($1, $2, $3, $4, $5) RETURNING *`,
      [title, description, gcsVideoPath, gcsThumbPath, req.user.id]
    );

    await fs.unlink(file.path);
    await fs.unlink(thumbPath);

    res.status(201).json({ message: "Video uploaded successfully.", video: rows[0] });
  } catch (err) {
    console.error("Upload failed:", err);
    res.status(500).json({ error: "Upload failed.", details: err.message });
  }
});

// Home Page with Pagination
app.get("/api/videos/home", async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const results = await getPaginatedResults(
      "SELECT v.*, u.username FROM videos v JOIN users u ON v.user_id = u.id ORDER BY v.id DESC",
      [],
      page,
      limit
    );
    res.json(results);
  } catch (err) {
    res.status(500).json({ error: "Failed to fetch videos.", details: err.message });
  }
});

// Search API with pagination
app.get("/api/videos/search", async (req, res) => {
  try {
    const { query } = req.query;
    if (!query) return res.status(400).json({ error: "Search query is required." });

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const searchQuery = `%${query}%`;
    const results = await getPaginatedResults(
      "SELECT v.*, u.username FROM videos v JOIN users u ON v.user_id = u.id WHERE v.title ILIKE $1 OR v.description ILIKE $1 ORDER BY v.id DESC",
      [searchQuery],
      page,
      limit
    );
    res.json(results);
  } catch (err) {
    res.status(500).json({ error: "Failed to perform search.", details: err.message });
  }
});

// Get a single video
app.get("/api/videos/:id", async (req, res) => {
  try {
    const videoId = req.params.id;
    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      const { rows } = await client.query(
        "SELECT v.*, u.username FROM videos v JOIN users u ON v.user_id = u.id WHERE v.id = $1",
        [videoId]
      );
      if (rows.length === 0) {
        return res.status(404).json({ error: "Video not found." });
      }

      const video = rows[0];
      await client.query("UPDATE videos SET views = views + 1 WHERE id = $1", [videoId]);

      await client.query("COMMIT");

      const [videoUrl] = await bucket.file(video.gcs_path).getSignedUrl({ action: "read", expires: Date.now() + 3600 * 1000 });
      const [thumbUrl] = await bucket.file(video.thumbnail_path).getSignedUrl({ action: "read", expires: Date.now() + 3600 * 1000 });

      res.json({ ...video, videoUrl, thumbUrl });
    } finally {
      client.release();
    }
  } catch (err) {
    res.status(500).json({ error: "Error fetching video.", details: err.message });
  }
});

// Video Reaction with Transaction
app.post("/api/videos/:id/react", auth, async (req, res) => {
  const { type } = req.body;
  const videoId = req.params.id;
  const userId = req.user.id;

  if (!["like", "dislike"].includes(type)) return res.status(400).json({ error: "Invalid reaction type." });

  const client = await pool.connect();
  try {
    await client.query("BEGIN");

    const { rows: existing } = await client.query(
      "SELECT * FROM video_reactions WHERE user_id = $1 AND video_id = $2",
      [userId, videoId]
    );

    if (existing.length > 0) {
      if (existing[0].type === type) {
        await client.query("DELETE FROM video_reactions WHERE user_id = $1 AND video_id = $2", [userId, videoId]);
      } else {
        await client.query("UPDATE video_reactions SET type = $1 WHERE user_id = $2 AND video_id = $3", [type, userId, videoId]);
      }
    } else {
      await client.query("INSERT INTO video_reactions(user_id, video_id, type) VALUES($1, $2, $3)", [userId, videoId, type]);
    }

    const likesRes = await client.query("SELECT COUNT(*) FROM video_reactions WHERE video_id = $1 AND type = 'like'", [videoId]);
    const dislikesRes = await client.query("SELECT COUNT(*) FROM video_reactions WHERE video_id = $1 AND type = 'dislike'", [videoId]);

    const likes = parseInt(likesRes.rows[0].count);
    const dislikes = parseInt(dislikesRes.rows[0].count);

    await client.query("UPDATE videos SET likes = $1, dislikes = $2 WHERE id = $3", [likes, dislikes, videoId]);
    await client.query("COMMIT");

    res.json({ message: "Reaction updated successfully." });
  } catch (err) {
    await client.query("ROLLBACK");
    res.status(500).json({ error: "Error updating reaction.", details: err.message });
  } finally {
    client.release();
  }
});

// Get User Profile Videos
app.get("/api/profile/videos", auth, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const results = await getPaginatedResults(
      "SELECT * FROM videos WHERE user_id = $1 ORDER BY id DESC",
      [req.user.id],
      page,
      limit
    );
    res.json(results);
  } catch (err) {
    res.status(500).json({ error: "Failed to fetch user videos.", details: err.message });
  }
});

// Edit Video
app.put("/api/videos/:id", auth, async (req, res) => {
  const { title, description } = req.body;
  const videoId = req.params.id;
  try {
    const { rows } = await pool.query("SELECT user_id FROM videos WHERE id = $1", [videoId]);
    if (rows.length === 0) return res.status(404).json({ error: "Video not found." });
    if (rows[0].user_id !== req.user.id) return res.status(403).json({ error: "You are not authorized to edit this video." });

    await pool.query("UPDATE videos SET title = $1, description = $2 WHERE id = $3", [title, description, videoId]);
    res.json({ message: "Video updated successfully." });
  } catch (err) {
    res.status(500).json({ error: "Failed to update video.", details: err.message });
  }
});

// Delete Video
app.delete("/api/videos/:id", auth, async (req, res) => {
  const videoId = req.params.id;
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    const { rows } = await client.query("SELECT user_id, gcs_path, thumbnail_path FROM videos WHERE id = $1", [videoId]);
    if (rows.length === 0) {
      await client.query("ROLLBACK");
      return res.status(404).json({ error: "Video not found." });
    }
    if (rows[0].user_id !== req.user.id) {
      await client.query("ROLLBACK");
      return res.status(403).json({ error: "You are not authorized to delete this video." });
    }

    await bucket.file(rows[0].gcs_path).delete();
    await bucket.file(rows[0].thumbnail_path).delete();
    await client.query("DELETE FROM videos WHERE id = $1", [videoId]);
    await client.query("COMMIT");
    res.json({ message: "Video deleted successfully." });
  } catch (err) {
    await client.query("ROLL
